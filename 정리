객체지향
    - 코드의 재사용성을 보장.

디자인 원칙.
        1.어플리케이션에서 달라지는 부분과 달라지지 않는 부분을 분리.
            - 바뀌는 부분은 따로 뽑아서 캡슐화시킨다. 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치고 확장할 수 있다.
        2.구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.
            - 인터페이스에 맞춰스 프로그래밍 한다는 것은 상위 형식(super type)에 맞춰서 프로그래밍한다를 의미한다.
                -> 런타임시 레퍼런스 변수에 실제 객체의 형식을 몰라도 사용할 수 있고, 상위 형식을 구현한 어떠한 클래스도 상위 타입의 레퍼런스에 저장할 수 있다 (다양성).
        3.상속보다는 구성을 활용한다.
            - "A는 B이다" 보다 "A에는 B가 있다" 가 시스템의 유연성을 크게 확장한다.
        4.서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합(Loose Coupling)하는 디자인(인터페이스가 중재)을 사용해야 한다.
            - 상호작용하는 객체는 인터페이스를 통해 대화해야 한다.

Strategy Pattern (전략 패턴)
    - 알고리즘군(변하는 부분, 행위:Behavior, Strategy)을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다. 스트레티지 패턴을 활용하면
    알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.

    상속을 통한 다양성을 구현
        단점 - 슈퍼 클래스에 변화가 생기면, 서브클래스가 모두 영향을 받는다.
            (코드를 변경했을 때 다른 서브 클래스에 원치 않은 영향을 끼칠 수 있다.)
    인터페이스를 통한 다양성 구현
        단점 - 인터페이스에는 구현된 코드가 전혀 들어가지 않기 때문에 코드 재사용이 불가. (만약 변화가 생길시 구현한 모든 클래스의 코드를 보수해야됨)

디자인 패턴의 도구
    객체지향 - 추상화, 캡슐화, 다형성, 상속
    객체지향 원칙
        - 1. 바뀌는 부분은 캡슐화 한다.
        - 2. 상속보다는 구성을 활용한다.
        - 3. 구현이 아닌 인터페이스에 맞춰 프로그래밍한다.
    디자인 패턴의 예
        - 1. 스트레티지 패턴
            : 알고리즘군을 정의하고 각각을 "캡슐화" 하여 바꿔 쓸 수 있게 만든다.


옵저버 패턴.
    - 발행자(Subject), 구독자(Observer) 로 구성.
        : Subject 에서 데이터를 관리한다.
        : Subject 의 데이터가 달라지면 Observer 에게 발행된다.
        : Observer 은 Subject 객체를 구독하며, Subject 가 데이터가 달라지면 갱신 내용을 전달 받는다.
        : 발행, 구독, 구독 해지.
    - 옵저버 패턴은 한 객체 (Subject) 의 상태가 바뀌면, 그 객체에 의존하는 다른 객체 (Observers) 에 연락이 가고 자동으로 내용이 갱싱되는 방식의 일대다 (one-to-many) 의존성을 정의.
        : 일련의 객체들 사에에서 one-to-many 관계가 정의된다.
        : 한 객체의 상태가 변경되면 그 객체에 의존하는 모든 객체(observers) 에게 연락이 간다.
    - 옵저버에 연락이 가는 순서에 의존하면 안된다.
    클래스 다이어그램
        Subject
            registerObserver(Observer observer)
            removeObserver(Observer observer)
            notifyObservers()
        Observer
            update()

    옵저버 패턴과 Loose Coupling
        - 옵저버 패턴에서 Subject 와 Observer 는 Loose Coupling 연결되어 있다.
        - 두 객체가 느슨하게 결합(Loose Coupling)되어 있다는 것은, 그 둘이 상호작용하지만 서로에 대해 잘 모른다(인터페이스를 이용한 대화: 인터페이스가 중재) 것을 의미.
        - Loose Coupling 을 사용하면 변경 사항이 생겨도 무난히 처리할 수 있는 객체지향 시스템을 구축할 수 있다.
        Loose Coupling 과 옵저버 패턴.
            - Subject 가 Observer 에 대해 아는 것은 옵저버가 특정 인터페이스를 구현한다는 것 뿐이다.
            - Observer 는 Observer 을 구현한 클래스면 언제든지 새로 추가할 수 있다.
            - 새로운 형식의 Observer 을 추가해도, Subject 에 전혀 영향이 가지 않는다.
            - Subject 와 Observer 를 독립적으로 재사용할 수 있다.
            - Subject 와 Observer 을 완전히 바꾸더라고 서로한테 영향이 가지 않는다.

    자바 내장 Observer 와 Observable.
        Subject = Observable, Observer = Observer
        - 푸쉬 방식(push) 과 풀 방식(pull) 모두 지원.
        Observable: 모든 Observers 을 관리하고 구독을 수취한다.

        자바 내장 Observer 작동 방식.
        1. Observer 인터페이를 구현하고 Observable 객체의 addObserver() 메서드를 호출.
        2. Observable 클래스를 확장하고 객체의 상태가 변경되었을때 setChanged() - (Observable.changed 프러퍼티를 true로 설정.) 메서드를 호출.
        Observable 에서 연락을 전달 방법.
            3. notifyObservers() 또는 notifyObservers(Object data) 메서드를 호출.
        Observer 가 연락을 받는 방법.
            4. update(Observable o, Object data) 메서드를 호출.


