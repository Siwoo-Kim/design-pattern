객체지향
    - 코드의 재사용성을 보장.

디자인 원칙.
        1.어플리케이션에서 달라지는 부분과 달라지지 않는 부분을 분리.
            - 바뀌는 부분은 따로 뽑아서 캡슐화시킨다. 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치고 확장할 수 있다.
        2.구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.
            - 인터페이스에 맞춰스 프로그래밍 한다는 것은 상위 형식(super type)에 맞춰서 프로그래밍한다를 의미한다.
                -> 런타임시 레퍼런스 변수에 실제 객체의 형식을 몰라도 사용할 수 있고, 상위 형식을 구현한 어떠한 클래스도 상위 타입의 레퍼런스에 저장할 수 있다 (다양성).
        3.상속보다는 구성을 활용한다.
            - "A는 B이다" 보다 "A에는 B가 있다" 가 시스템의 유연성을 크게 확장한다.
        4.서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합(Loose Coupling)하는 디자인(인터페이스가 중재)을 사용해야 한다.
            - 상호작용하는 객체는 인터페이스를 통해 대화해야 한다.
        5.OCP (Open-Closed Principle)
            - 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다.

Strategy Pattern (전략 패턴)
    - 알고리즘군(변하는 부분, 행위:Behavior, Strategy)을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다. 스트레티지 패턴을 활용하면
    알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.

    상속을 통한 다양성을 구현
        단점 - 슈퍼 클래스에 변화가 생기면, 서브클래스가 모두 영향을 받는다.
            (코드를 변경했을 때 다른 서브 클래스에 원치 않은 영향을 끼칠 수 있다.)
    인터페이스를 통한 다양성 구현
        단점 - 인터페이스에는 구현된 코드가 전혀 들어가지 않기 때문에 코드 재사용이 불가. (만약 변화가 생길시 구현한 모든 클래스의 코드를 보수해야됨)

디자인 패턴의 도구
    객체지향 - 추상화, 캡슐화, 다형성, 상속
    객체지향 원칙
        - 1. 바뀌는 부분은 캡슐화 한다.
        - 2. 상속보다는 구성을 활용한다.
        - 3. 구현이 아닌 인터페이스에 맞춰 프로그래밍한다.
    디자인 패턴의 예
        - 1. 스트레티지 패턴
            : 알고리즘군을 정의하고 각각을 "캡슐화" 하여 바꿔 쓸 수 있게 만든다.


옵저버 패턴.
    - 발행자(Subject), 구독자(Observer) 로 구성.
        : Subject 에서 데이터를 관리한다.
        : Subject 의 데이터가 달라지면 Observer 에게 발행된다.
        : Observer 은 Subject 객체를 구독하며, Subject 가 데이터가 달라지면 갱신 내용을 전달 받는다.
        : 발행, 구독, 구독 해지.
    - 옵저버 패턴은 한 객체 (Subject) 의 상태가 바뀌면, 그 객체에 의존하는 다른 객체 (Observers) 에 연락이 가고 자동으로 내용이 갱싱되는 방식의 일대다 (one-to-many) 의존성을 정의.
        : 일련의 객체들 사에에서 one-to-many 관계가 정의된다.
        : 한 객체의 상태가 변경되면 그 객체에 의존하는 모든 객체(observers) 에게 연락이 간다.
    - 옵저버에 연락이 가는 순서에 의존하면 안된다.
    클래스 다이어그램
        Subject
            registerObserver(Observer observer)
            removeObserver(Observer observer)
            notifyObservers()
        Observer
            update()

    옵저버 패턴과 Loose Coupling
        - 옵저버 패턴에서 Subject 와 Observer 는 Loose Coupling 연결되어 있다.
        - 두 객체가 느슨하게 결합(Loose Coupling)되어 있다는 것은, 그 둘이 상호작용하지만 서로에 대해 잘 모른다(인터페이스를 이용한 대화: 인터페이스가 중재) 것을 의미.
        - Loose Coupling 을 사용하면 변경 사항이 생겨도 무난히 처리할 수 있는 객체지향 시스템을 구축할 수 있다.
        Loose Coupling 과 옵저버 패턴.
            - Subject 가 Observer 에 대해 아는 것은 옵저버가 특정 인터페이스를 구현한다는 것 뿐이다.
            - Observer 는 Observer 을 구현한 클래스면 언제든지 새로 추가할 수 있다.
            - 새로운 형식의 Observer 을 추가해도, Subject 에 전혀 영향이 가지 않는다.
            - Subject 와 Observer 를 독립적으로 재사용할 수 있다.
            - Subject 와 Observer 을 완전히 바꾸더라고 서로한테 영향이 가지 않는다.

    자바 내장 Observer 와 Observable.
        Subject = Observable, Observer = Observer
        - 푸쉬 방식(push) 과 풀 방식(pull) 모두 지원.
        Observable: 모든 Observers 을 관리하고 구독을 수취한다.

        자바 내장 Observer 작동 방식.
        1. Observer 인터페이를 구현하고 Observable 객체의 addObserver() 메서드를 호출.
        2. Observable 클래스를 확장하고 객체의 상태가 변경되었을때 setChanged() - (Observable.changed 프러퍼티를 true로 설정.) 메서드를 호출.
        Observable 에서 연락을 전달 방법.
            3. notifyObservers() 또는 notifyObservers(Object data) 메서드를 호출.
        Observer 가 연락을 받는 방법.
            4. update(Observable o, Object data) 메서드를 호출.

상속의 문제점
        - 상속을 통해 확장할 수 있지만, 컴파일 단계에서 이미 확장은 닫히므로 디자인 유연성에서는 좋지 못하다.
        - 상속은 기존 코드를 수정하지 않고 행동을 확장할 수 없다.
        - 상속 대신 구성과 위임을 통해 실행 중 새로운 행동을 추가할 수 있다.
        - 상속 대신 데코레이터 패턴을 통해 클래스를 확장하여 행동을 추가할 수 있다.


데코레이터 패턴.
    * 데코레이터 패턴은 상속 대신 객체에 추가적인 기능(행동)을 동적으로 첨가한다.
        - 상속과의 차이: 런타임에 클래스를 상속할 수 있다. 타겟 클래스의 레퍼런스를 가지고 있으며 행동을 위임할 수 있으므로 구성과 상속 메커니즘을 조합.
    * 클라이언트는 데코레이터의 존재를 알 수 없다.
    * 런타임시 해당 클래스를 바탕으로 한 작업 처리 (instance of) 가 제대로 작동하지 않는다.
    * 데코레이터는 일반적으로 팩토리나 빌더 같은 패턴을 사용해서 초기화 작업을 같이 진행한다. (데코레이터가 하나 이상일 경우 Ordering 을 지정하기 위해서)
    * 데코레이터 패턴의 예:
        자바 I/O API
            - new LineNumberInputStream(new BufferedInputStream(new FileInputStream()))
            - 모두 InputStream 을 상속.

    - 데코레이터 패턴은 Wrapper 클래스를 이용하여 동적으로 클래스를 확장하는 방법을 제공한다.
    - Wrapper 클래스의 SuperClass 은 타겟 클래스의 SuperClass 와 같다. (즉, 타겟 클래스는 추상, 혹은 인터페이스를 확장된 클래스여야 한다)
    - 한 타겟 클래스를 여러개의 데코레이터로 Wrap 할 수 있다.
    - Wrapper 클래스는 다른 Wrapper 클래스를 Wrap 할 수 있다.
    - Wrapper 클래스는 타겟 클래스에 해동을 위임하거나, 원하는 추가적인 기능을 수행할 수 있다.
    - 실행중에 Wrapper 클래스를 얼마든지 생성하여 추가 기능을 타겟 클래스에 부여할 수 있다.




