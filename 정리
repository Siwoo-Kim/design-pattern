객체지향
    - 코드의 재사용성을 보장.

디자인 원칙.
        1.어플리케이션에서 달라지는 부분과 달라지지 않는 부분을 분리.
            - 바뀌는 부분은 따로 뽑아서 캡슐화시킨다. 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치고 확장할 수 있다.
        2.구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.
            - 인터페이스에 맞춰스 프로그래밍 한다는 것은 상위 형식(super type)에 맞춰서 프로그래밍한다를 의미한다.
                -> 런타임시 레퍼런스 변수에 실제 객체의 형식을 몰라도 사용할 수 있고, 상위 형식을 구현한 어떠한 클래스도 상위 타입의 레퍼런스에 저장할 수 있다 (다양성).
        3.상속보다는 구성을 활용한다.
            - "A는 B이다" 보다 "A에는 B가 있다" 가 시스템의 유연성을 크게 확장한다.
        4.서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합(Loose Coupling)하는 디자인(인터페이스가 중재)을 사용해야 한다.

Strategy Pattern (전략 패턴)
    - 알고리즘군(변하는 부분, 행위:Behavior, Strategy)을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다. 스트레티지 패턴을 활용하면
    알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.

    상속을 통한 다양성을 구현
        단점 - 슈퍼 클래스에 변화가 생기면, 서브클래스가 모두 영향을 받는다.
            (코드를 변경했을 때 다른 서브 클래스에 원치 않은 영향을 끼칠 수 있다.)
    인터페이스를 통한 다양성 구현
        단점 - 인터페이스에는 구현된 코드가 전혀 들어가지 않기 때문에 코드 재사용이 불가. (만약 변화가 생길시 구현한 모든 클래스의 코드를 보수해야됨)

디자인 패턴의 도구
    객체지향 - 추상화, 캡슐화, 다형성, 상속
    객체지향 원칙
        - 1. 바뀌는 부분은 캡슐화 한다.
        - 2. 상속보다는 구성을 활용한다.
        - 3. 구현이 아닌 인터페이스에 맞춰 프로그래밍한다.
    디자인 패턴의 예
        - 1. 스트레티지 패턴
            : 알고리즘군을 정의하고 각각을 "캡슐화" 하여 바꿔 쓸 수 있게 만든다.


옵저버 패턴.
    - 발행자(Subject), 구독자(Observer) 로 구성.
        : Subject 에서 데이터를 관리한다.
        : Subject 의 데이터가 달라지면 Observer 에게 발행된다.
        : Observer 은 Subject 객체를 구독하며, Subject 가 데이터가 달라지면 갱신 내용을 전달 받는다.
    - 옵저버 패턴은 한 객체 (Subject) 의 상태가 바뀌면, 그 객체에 의존하는 다른 객체 (Observers) 에 연락이 가고
        자동으로 내용이 갱싱되는 방식의 일대다 (one-to-many) 의존성을 정의.
    클래스 다이어그램
        Subject
            registerObserver(Observer observer)
            removeObserver(Observer observer)
            notifyObservers()
        Observer
            update()

    Loose Coupling
        - 두 객체가 느슨하게 결합(Loose Coupling)되어 있다는 것은, 그 둘이 상호작용하지만 서로에 대해 잘 모른다(인터페이스를 이용한 대화: 인터페이스가 중재) 것을 의미.
        - Loose Coupling 을 사용하면 변경 사항이 생겨도 무난히 처리할 수 있는 객체지향 시스템을 구축할 수 있다.
        Loose Coupling 과 옵저버 패턴.
            - Subject 가 Observer 에 대해 아는 것은 옵저버가 특정 인터페이스를 구현한다는 것 뿐이다.
            - Observer 는 Observer 을 구현한 클래스면 언제든지 새로 추가할 수 있다.
            - 새로운 형식의 Observer 을 추가해도, Subject 에 전혀 영향이 가지 않는다.
            - Subject 와 Observer 를 독립적으로 재사용할 수 있다.
            - Subject 와 Observer 을 완전히 바꾸더라고 서로한테 영향이 가지 않는다.

