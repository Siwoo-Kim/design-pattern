
디자인 패턴.

디자인 원칙.
    디자인 원칙 1. 어플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다.
        - 바뀌는 부분은 따로 뽑아내서 캡슐화시킨다. 그렇게 하면 바뀌지 않은 부분에는 영향을 미치지 않은채, 바뀐 부분만 고치거나 확장할 수 있다.
        오리가 수영하는 방법은 바뀌지 않는다. <- 바뀌는 부분이 캡슐화 되어 변경될땐, 이 부분엔 영향이 가지 않는다.
        특정 오리는 날 수 있지만, 또 다른 오리는 날 수 없다. <- 캡슐화한다.
        오리마다 내는 소리가 다르다. <- 캡슐화한다.

    상속.
        장점
            - 상속은 코드를 재사용할 수 있게 해준다.
            - 다형성
        단점
            - 코드를 재정비하기 어렵다.
            - 슈퍼 클래스의 코드가 변경되었을 때, 하위 클래스에 원치 않은 영향을 끼칠 수 있다.

    인터페이스 구현.
        장점
            - 상속과 더불어 활용하면, 하나의 슈퍼 클래스에서 파생된 서브 클래스에 다른 행동을 구현하도록 강요할 수 있다. (다중 상속)
                public class RubberDuck extends AbstractDuck implements Flyable, Quackable
        단점
            - 구현된 코드가 전혀 들어가지 않기 때문에 코드 재사용을 할 수 없다.
            - 특정 행동을 바꿀 때마다 모든 서브클래스를 전부 찾아서 코드를 일일이 고쳐야 하므로, 버그가 발생된 가능성이 생긴다.

    디자인 원칙 2. 구현이 아닌 인터페이스 맞춰서 프로그래밍한다.
        - 바뀌는 부분을 인터페이스로 표현하고, 구현할 때 인터페이스를 구현하도록 한다. (런타임시 동적으로 행동을 부여할 수 있다.:다형성)
        - 여기서 인터페이스란 상위 형식(supertype) 을 의미한다. 상위 형식이란 인터페이스 나 추상 클래스를 의미한다.
        - 상위 형식에 맞춰서 프로그래밍하라는 상위 형식에 맞춰서 다형성을 활용하라와 같은 의미이다.
        다형성
            - 변수를 선언할 때 추상 클래스나 인터페이스로 타입을 지정하고, 변수에 대입할 때 특정 구현된 형식을 런타임에 부여한다.
            - 변수를 선언하는 클라이언트에서는 실제 객체의 형식을 몰라도 된다.
            Animal animal = new Dog();
            animal.sound();
            animal = getAnimal("cat"); // new 연산자 대신, 구체적인 객체의 생성방법을 캡슐화(FactoryPattern) 하면 코드의 유연성이 더 향상된다.
            animal.sound();

    Strategy Pattern.
        - strategy pattern 에서는 알고리즘군을 정의하고 각각을 캡슐화해서 교환할 수 있게 만든다.
        스트레티지을 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다. (상속시에 특정 알고리즘을 변경할 시, 어떤 문제가 생겼는지 생각하고 비교해보자)
        특정 달라지는 부분을 family of algorithms 이라 부른다.
        특정 달라지지 않는 부분을 context 라 하며, 상위 클래스로 추상화하여 뽑아 낸다.
        달라지는 부분은 인터페이스로 뽑아낸다.(상위 형식에 맞춰 프로그래밍 한다.)
        달라지는 부분을 구현한 클래스를 설계한다.
        context 에서 위에서 생성한 인터페이스의 레퍼런스를 선언하고, 행동을 위임한다. (구성: composition)
    디자인 원칙 3. 상속보다는 구성을 활용한다.
        구성을 이용하면 시스템의 유연성을 크게 향상시킬 수 있으며, family of algorithms 을 클래스 집합으로 캡슐화 시켜주며
        구성요소로 사용하는 객체(클라이언트, 혹은 의존 객체) 실행시에 행동을 바꿀 수 있다.

옵저버 패턴
    시작하기 전:
        구체적인 구현을 바탕으로 프로그래밍 하지 말아라 - (인터페이스 맞춰서 프로그래밍하라.)
        공통적인 인터페이스를 구현하여 사용하라
        달라지는 부분을 캡슐화하여라.
    - 옵저버 패턴에서는 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱싱되는
    방식으로 일대다 의존성을 정의한다. (주제:One - 구독자:Many)

    주제 (Subject 혹은 Observable) 와 구독자 (Observer) 로 이루어졌다.
        - 주제 객체에서는 데이터를 관리한다.
        - 주제 객체의 데이터가 달라지면 구독자 (Observer) 에게 전달된다.
        - 구독자 (Observer) 은 주제 객체를 구독하며, 주제 객체의 데이터가 바뀌면 갱신 내용을 전달 받는다.

    디자인 원칙 4. 서로 상호작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용하라.
        느슨한 결합(Loose Coupling).
            두 객체가 느슨하게 결하되어 있다는 것은, 둘이 상호작용할때 인터페이스를 통해 대화한다는 것이다. (구현 클래스를 알지 못한다)
            - 얼마든지 의존 구현 클래스를 교체할 수 있다.
            - 둘 중 하나가 바뀌더라도 서로한테 영향을 미치지 않는다.
            - 다른 용도로 독립적으로 재사용할 수 있다.

    자바 내장 옵저버 패턴.
        Observable 클래스(Subject)와 Observer 인터페이스(구독자)

        객체가 Observer 가 되는 방법.
            java.util.Observer 을 구현하고 Observable 객체의 addObserver 메서드를 호출.
        주제(Observable) 에서 연락을 돌리는 방법.
            java.util.Observable 를 확장하고 setChanged() 메서드를 호출하여 객체의 상태가 바뀌는 것을 알림.
            이후 notifyObservers(Object arg) 를 호출.
        Observer 가 연락을 받는 방법.
            update(Observable o, Object arg) 메서드를 구현. (Push 방식)

    Swing 의 옵저버 패턴.
        스윙의 구성 요소는 Subject 역할을 담당 (데이터를 지닌 객체).
        Listener 로 postfix 끝나는 클래스는 Observer 역할을 담당 (구독하는 객체).
            ex) JButton.addActionListener(new SomeListener()); - Observer 를 등록 시킨다.
            SomeListener.actionPerformed(ActionEvent event); - 데이터가 변경되어 알림이 발동된다 ( = Observer.update() )

    옵저버 패턴시 주의점.
        연락이 가는 순서에 의존하지 마라.


데코레이터 패턴.
    * 객체에 추가적인 요건을 동적으로 첨가한다. 데코레이터는 서브 클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다. (동적으로 상속)
    상속보단 구성을 사용하자: 상속으로 부모 클래스의 행동을 물려받으면, 그 행동은 컴파일시에 완전히 결정된다.
    하지만 구성과 위임을 통해 객체의 행동을 확장하면 실행중에 동적으로 행동을 결정할 수 있다.
    디자인 원칙 5. OCP(Open-Closed Principle)
        - 클래스는 확장에 대해서는 열려 있지만 코드 변경에 대해서는 닫혀 있어야 한다. (OCP 을 떠올릴때, 상속과 구성, 위임의 차이를 기억하자)

    데코레이터 객체.
        - 데코레이터의 수퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다.
        - 한 객체를 여러 개의 데코레이터 객체로 감쌀 수 있다.
        - 데코레이터는 타겟 객체와 같은 수퍼클래스를 가지고 있기 때문에 변수 레퍼런스에 대신 할당될 수 있다.
        - 데코레이터는 타겟 객체에 어떤 행동을 위임하는 것 외에 원하는 추가적인 작업을 수행할 수 있다.
        - 타겟 객체를 언제든지 감쌀 수 있기에 실행시에 동적으로 추가 기능을 추가할 수 있다. (런타임시 확장)








